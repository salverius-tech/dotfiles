# PowerShell Profile - managed by chezmoi

# ============================================
# PSReadLine Configuration
# ============================================
if (Get-Module -ListAvailable -Name PSReadLine) {
    Import-Module PSReadLine
    
    # Enable predictive IntelliSense (fish-style auto-suggestions)
    Set-PSReadLineOption -PredictionSource History
    Set-PSReadLineOption -PredictionViewStyle ListView
    
    # Better colors for syntax highlighting
    Set-PSReadLineOption -Colors @{
        Command = 'Cyan'
        Parameter = 'DarkCyan'
        Type = 'DarkYellow'
        Variable = 'Green'
        String = 'DarkGreen'
        Operator = 'DarkGray'
        Number = 'DarkBlue'
    }
    
    # Key bindings
    Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete
    Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward
    Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward
    Set-PSReadLineKeyHandler -Chord 'Ctrl+d' -Function DeleteChar
    Set-PSReadLineKeyHandler -Chord 'Ctrl+w' -Function BackwardKillWord
}

# ============================================
# Cross-Platform Commands
# ============================================

# which equivalent
function which($name) {
    Get-Command $name -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source
}

# pbcopy/pbpaste (macOS-like)
function pbcopy {
    $input | clip.exe
}

function pbpaste {
    Get-Clipboard
}

# touch (create empty file)
function touch($file) {
    if (Test-Path $file) {
        (Get-Item $file).LastWriteTime = Get-Date
    } else {
        New-Item -ItemType File -Path $file | Out-Null
    }
}

# open (like macOS)
function open($path = '.') {
    Invoke-Item $path
}

# ============================================
# Smart cd with history
# ============================================
$global:cdHistory = @{}

function cd {
    param([string]$path = '')
    
    if ([string]::IsNullOrEmpty($path)) {
        Set-Location ~
    } elseif ($path -eq '-') {
        # Go to previous directory
        if ($global:cdHistory.ContainsKey('prev')) {
            Set-Location $global:cdHistory['prev']
        }
    } else {
        # Store current before changing
        $global:cdHistory['prev'] = Get-Location
        
        # Try to resolve path
        $resolved = Resolve-Path $path -ErrorAction SilentlyContinue
        if ($resolved) {
            Set-Location $resolved
        } else {
            # Try partial match
            $matches = Get-ChildItem -Directory | Where-Object { $_.Name -like "*$path*" }
            if ($matches.Count -eq 1) {
                Set-Location $matches[0]
            } else {
                Set-Location $path
            }
        }
    }
}

# ============================================
# SSH Agent (Windows OpenSSH)
# ============================================
$sshAgent = Get-Service -Name ssh-agent -ErrorAction SilentlyContinue
if ($sshAgent -and $sshAgent.Status -ne 'Running') {
    # Check if we have permission to start the service
    try {
        Start-Service ssh-agent -ErrorAction Stop
    } catch {
        Write-Warning "Could not start ssh-agent. Ensure the service is not disabled and you have admin rights."
        Write-Warning "To enable: Set-Service ssh-agent -StartupType Automatic"
    }
}


# Add keys automatically
$sshDir = Join-Path $env:USERPROFILE '.ssh'
if (Test-Path $sshDir) {
    Get-ChildItem $sshDir -Filter 'id_*' -Exclude '*.pub' | ForEach-Object {
        ssh-add $_.FullName 2>$null
    }
}

# ============================================
# Original Aliases and Functions
# ============================================

# Aliases matching bash config
Set-Alias -Name kc -Value kubectl

function l { Get-ChildItem -Force @args }
function cddev { Set-Location C:\dev }

# Docker aliases (only if docker is installed)
if (Get-Command docker -ErrorAction SilentlyContinue) {
    # Container Listing
    function dps { docker ps --format="table {{`{{.Names}}`}}`t{{`{{.ID}}`}}`t{{`{{.Image}}`}}`t{{`{{.RunningFor}}`}}`t{{`{{.State}}`}}`t{{`{{.Status}}`}}" }
    function dpsp { docker ps --format="table {{`{{.Names}}`}}`t{{`{{.ID}}`}}`t{{`{{.Image}}`}}`t{{`{{.RunningFor}}`}}`t{{`{{.State}}`}}`t{{`{{.Status}}`}}`t{{`{{.Ports}}`}}" }
    function dpsa { docker ps -a @args }

    # Docker Compose
    function dc { docker compose @args }
    function dcu { docker compose up -d @args }
    function dcd { docker compose down @args }
    function dcl { docker compose logs -f @args }
    function dcr { docker compose restart @args }
    function dcp { docker compose pull @args }
    function dcb { docker compose build @args }
    function dce { docker compose exec @args }
    function dcps { docker compose ps @args }
    function dcconf { docker compose config @args }

    # Container Operations
    function dlog { docker logs -f @args }
    function dlast { docker logs --tail 100 @args }
    function dexec { docker exec -it @args }
    function dstop { docker stop @args }
    function drm { docker rm @args }

    # Inspection
    function dins { docker inspect @args }
    function dip { docker inspect -f '{{`{{range.NetworkSettings.Networks}}`}}{{`{{.IPAddress}}`}}{{`{{end}}`}}' @args }
    function dtop { docker stats --no-stream @args }
    function dwatch { docker stats @args }

    # Images
    function di { docker images @args }
    function drmi { docker rmi @args }
    function dpull { docker pull @args }

    # Network & Volumes
    function dnet { docker network ls @args }
    function dvol { docker volume ls @args }

    # Cleanup
    function docker-prune { docker system prune -f @args }
    function docker-prune-all { docker system prune -af --volumes @args }

    # Shell into container
    function dsh { docker exec -it $args[0] /bin/sh }
    function dbash { docker exec -it $args[0] /bin/bash }
}

# Network
function ipa { Get-NetIPAddress | Where-Object { $_.AddressFamily -eq 'IPv4' } | Format-Table InterfaceAlias, IPAddress }
function ipn { Get-NetNeighbor | Format-Table }

# Update alias
function update { winget upgrade --all --include-unknown }

# ============================================
# Docker Status in Prompt (when Starship unavailable)
# ============================================
function Get-DockerStatus {
    if (Get-Command docker -ErrorAction SilentlyContinue) {
        $dockerInfo = docker info 2>&1
        if ($LASTEXITCODE -eq 0) {
            return " [Docker:Running]"
        } else {
            return " [Docker:Stopped]"
        }
    }
    return ""
}

# ============================================
# Initialize Starship or Custom Prompt
# ============================================
if (Get-Command starship -ErrorAction SilentlyContinue) {
    Invoke-Expression (&starship init powershell)
} else {
    # Custom prompt with Docker status
    function prompt {
        $location = Get-Location
        $dockerStatus = Get-DockerStatus
        "PS $location$dockerStatus> "
    }
}
